use super::*;

#[test]
fn test_key_expansion_g() {
    /*
    let key: [u8; 16] = [
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88,
    ];
    dbg!(key_expansion(&key));
    */

    // See: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
    // The "after xor with rcon" is what we're testing with key_expansion_g.
    // This only happens every four keys, which is what key_expansion does too.
    // The "wrd" value is the word to be used in key_expansion_g, i.e. if we're
    // trying to work out key-word 12, wrd would be key-word 11, and then we're
    // just asserting that the key-word 12 we got is the actual key-word 12.

    let wrd = [0x09, 0xcf, 0x4f, 0x3c]; // Word 3 to calculate word 4
    assert_eq!(key_expansion_g(1, wrd), [0x8b, 0x84, 0xeb, 0x01]);

    let wrd2 = [0xdb, 0x0b, 0xad, 0x00]; // Word 19 to calculate word 20
    assert_eq!(key_expansion_g(5, wrd2), [0x3b, 0x95, 0x63, 0xb9]);
}

#[test]
fn test_key_expansion() {
    let key: [u8; 16] = [
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f,
        0x3c,
    ];

    // The correct key expansion output
    let expanded_key = [
        key,
        [
            0xa0, 0xfa, 0xfe, 0x17, 0x88, 0x54, 0x2c, 0xb1, 0x23, 0xa3, 0x39, 0x39, 0x2a, 0x6c,
            0x76, 0x05,
        ],
        [
            0xf2, 0xc2, 0x95, 0xf2, 0x7a, 0x96, 0xb9, 0x43, 0x59, 0x35, 0x80, 0x7a, 0x73, 0x59,
            0xf6, 0x7f,
        ],
        [
            0x3d, 0x80, 0x47, 0x7d, 0x47, 0x16, 0xfe, 0x3e, 0x1e, 0x23, 0x7e, 0x44, 0x6d, 0x7a,
            0x88, 0x3b,
        ],
        [
            0xef, 0x44, 0xa5, 0x41, 0xa8, 0x52, 0x5b, 0x7f, 0xb6, 0x71, 0x25, 0x3b, 0xdb, 0x0b,
            0xad, 0x00,
        ],
        [
            0xd4, 0xd1, 0xc6, 0xf8, 0x7c, 0x83, 0x9d, 0x87, 0xca, 0xf2, 0xb8, 0xbc, 0x11, 0xf9,
            0x15, 0xbc,
        ],
        [
            0x6d, 0x88, 0xa3, 0x7a, 0x11, 0x0b, 0x3e, 0xfd, 0xdb, 0xf9, 0x86, 0x41, 0xca, 0x00,
            0x93, 0xfd,
        ],
        [
            0x4e, 0x54, 0xf7, 0x0e, 0x5f, 0x5f, 0xc9, 0xf3, 0x84, 0xa6, 0x4f, 0xb2, 0x4e, 0xa6,
            0xdc, 0x4f,
        ],
        [
            0xea, 0xd2, 0x73, 0x21, 0xb5, 0x8d, 0xba, 0xd2, 0x31, 0x2b, 0xf5, 0x60, 0x7f, 0x8d,
            0x29, 0x2f,
        ],
        [
            0xac, 0x77, 0x66, 0xf3, 0x19, 0xfa, 0xdc, 0x21, 0x28, 0xd1, 0x29, 0x41, 0x57, 0x5c,
            0x00, 0x6e,
        ],
        [
            0xd0, 0x14, 0xf9, 0xa8, 0xc9, 0xee, 0x25, 0x89, 0xe1, 0x3f, 0x0c, 0xc8, 0xb6, 0x63,
            0x0c, 0xa6,
        ],
    ];

    // Reorder output into words of 4 bytes instead of arrays of 16
    let mut cmp_key = [[0u8; 4]; 44];
    // Each word
    for i in 0..44 {
        // Each byte in a word
        for c in 0..4 {
            // i/4 gives the array idx, (i % 4) gives the index of
            // the word (e.g. 3 for the last word in an array entry)
            // and so (i % 4) * 4 gives the starting index for that
            // word. We then iterate over c to get the individual bytes.
            cmp_key[i][c] = expanded_key[i / 4][(i % 4) * 4 + c];
        }
    }

    assert_eq!(cmp_key, key_expansion(&key));
}

// https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf, Appendix B.
#[test]
fn test_xor_with_round_key() {
    let mut input: [[u8; 4]; 4] = [
        [0x32, 0x43, 0xf6, 0xa8],
        [0x88, 0x5a, 0x30, 0x8d],
        [0x31, 0x31, 0x98, 0xa2],
        [0xe0, 0x37, 0x07, 0x34],
    ];

    let round_key: [[u8; 4]; 4] = [
        [0x2b, 0x7e, 0x15, 0x16],
        [0x28, 0xae, 0xd2, 0xa6],
        [0xab, 0xf7, 0x15, 0x88],
        [0x09, 0xcf, 0x4f, 0x3c],
    ];

    let result: [[u8; 4]; 4] = [
        [0x19, 0x3d, 0xe3, 0xbe],
        [0xa0, 0xf4, 0xe2, 0x2b],
        [0x9a, 0xc6, 0x8d, 0x2a],
        [0xe9, 0xf8, 0x48, 0x08],
    ];
    xor_with_round_key(&mut input, &round_key);
    assert_eq!(result, input);
}

#[test]
fn test_sub_bytes() {
    // The correct output from first xor with round key
    // (i.e. the input to round 1)
    let mut input: [[u8; 4]; 4] = [
        [0x19, 0x3d, 0xe3, 0xbe],
        [0xa0, 0xf4, 0xe2, 0x2b],
        [0x9a, 0xc6, 0x8d, 0x2a],
        [0xe9, 0xf8, 0x48, 0x08],
    ];

    let result = [
        [0xd4, 0x27, 0x11, 0xae],
        [0xe0, 0xbf, 0x98, 0xf1],
        [0xb8, 0xb4, 0x5d, 0xe5],
        [0x1e, 0x41, 0x52, 0x30],
    ];

    substitute_bytes(&mut input);

    assert_eq!(input, result);
}

#[test]
fn test_shift_rows() {
    // First round, after sub_bytes.
    let mut input = [
        [0xd4, 0x27, 0x11, 0xae],
        [0xe0, 0xbf, 0x98, 0xf1],
        [0xb8, 0xb4, 0x5d, 0xe5],
        [0x1e, 0x41, 0x52, 0x30],
    ];

    let result = [
        [0xd4, 0xbf, 0x5d, 0x30],
        [0xe0, 0xb4, 0x52, 0xae],
        [0xb8, 0x41, 0x11, 0xf1],
        [0x1e, 0x27, 0x98, 0xe5],
    ];

    shift_rows(&mut input);
    assert_eq!(input, result);
}

#[test]
fn test_mix_columns() {
    // First round, after mix_columns.
    let mut input = [
        [0xd4, 0xbf, 0x5d, 0x30],
        [0xe0, 0xb4, 0x52, 0xae],
        [0xb8, 0x41, 0x11, 0xf1],
        [0x1e, 0x27, 0x98, 0xe5],
    ];
    let result = [
        [0x04, 0x66, 0x81, 0xe5],
        [0xe0, 0xcb, 0x19, 0x9a],
        [0x48, 0xf8, 0xd3, 0x7a],
        [0x28, 0x06, 0x26, 0x4c],
    ];
    mix_columns(&mut input);

    assert_eq!(input, result);
}

#[test]
fn test_finite_field_mult(){
    let a = 0x53;
    let b = 0xCA;
    let p = finite_field_mult(a, b);

    assert_eq!(p, 0x1);
}
